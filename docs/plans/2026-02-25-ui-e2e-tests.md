# UI E2E Tests Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Vollständige, isolierte UI-Testsuite in drei Layern: Snapshots, Integration und E2E-PTY — ohne Produktivdaten zu berühren.

**Architecture:** Zwei Env-Vars (`CLAUDE_DATA_DIR`, `AGENT_CONFIG_DIR`) entkoppeln die Binary von echten Pfaden. Layer 1 nutzt `TestBackend`+`insta` für Snapshots, Layer 2 ruft App-Methoden direkt auf, Layer 3 startet die echte Binary per PTY via `ratatui-testlib`.

**Tech Stack:** Rust, ratatui `TestBackend`, `insta`, `tempfile`, `ratatui-testlib = "0.1.0"`, `serde_json`

---

## Task 1: Env-Var-Isolation in `store.rs`

**Files:**
- Modify: `src/store.rs:44-53`

**Step 1: Failing test schreiben**

In `src/store.rs` am Ende des `#[cfg(test)]`-Blocks:
```rust
#[test]
fn test_new_uses_env_var_claude_data_dir() {
    let tmp = tempfile::TempDir::new().unwrap();
    std::env::set_var("CLAUDE_DATA_DIR", tmp.path());
    let store = SessionStore::new();
    assert_eq!(store.projects_path, tmp.path().to_path_buf());
    std::env::remove_var("CLAUDE_DATA_DIR");
}
```

**Step 2: Test ausführen — muss fehlschlagen**
```bash
cargo test test_new_uses_env_var_claude_data_dir
```
Erwartet: FAIL

**Step 3: Implementierung in `SessionStore::new()`**

```rust
pub fn new() -> Self {
    let base = if let Ok(dir) = std::env::var("CLAUDE_DATA_DIR") {
        PathBuf::from(dir)
    } else {
        dirs::home_dir().expect("home dir").join(".claude")
    };
    let projects_path = base.join("projects");
    let trash_path = base.join("trash.json");
    Self { projects_path, trash_path }
}
```

**Step 4: Test ausführen — muss grün sein**
```bash
cargo test test_new_uses_env_var_claude_data_dir
```

**Step 5: Commit**
```bash
git add src/store.rs
git commit -m "feat(store): support CLAUDE_DATA_DIR env var for test isolation"
```

---

## Task 2: Env-Var-Isolation in `config.rs`

**Files:**
- Modify: `src/config.rs:53-57`

**Step 1: Failing test schreiben**

In `src/config.rs` im `#[cfg(test)]`-Block:
```rust
#[test]
fn test_config_path_uses_env_var() {
    let tmp = tempfile::TempDir::new().unwrap();
    std::env::set_var("AGENT_CONFIG_DIR", tmp.path());
    let path = AppConfig::config_path();
    assert_eq!(path, tmp.path().join("config.json"));
    std::env::remove_var("AGENT_CONFIG_DIR");
}
```

**Step 2: Test ausführen — muss fehlschlagen**
```bash
cargo test test_config_path_uses_env_var
```

**Step 3: Implementierung in `config_path()`**

```rust
fn config_path() -> PathBuf {
    if let Ok(dir) = std::env::var("AGENT_CONFIG_DIR") {
        return PathBuf::from(dir).join("config.json");
    }
    dirs::config_dir()
        .expect("config dir")
        .join("agent-session-manager/config.json")
}
```

**Step 4: Test ausführen**
```bash
cargo test test_config_path_uses_env_var
```

**Step 5: Alle Tests grün**
```bash
cargo test
```
Erwartet: alle Tests grün.

**Step 6: Commit**
```bash
git add src/config.rs
git commit -m "feat(config): support AGENT_CONFIG_DIR env var for test isolation"
```

---

## Task 3: Layer 1 — Snapshot-Tests für Modals (`src/ui.rs`)

**Files:**
- Modify: `src/ui.rs` (im `mod tests`-Block am Ende)

Drei neue `insta`-Snapshot-Tests. Die `render_to_string`- und `make_session`/`make_msg`-Helfer existieren bereits.

**Step 1: Tests schreiben**

Nach dem letzten Test in `src/ui.rs`:
```rust
#[test]
fn test_snapshot_settings_modal() {
    let mut app = App::with_sessions(vec![make_session(
        "abc12345-6789", "my-project",
        vec![make_msg("user", "Hello")],
    )]);
    app.open_settings();
    let backend = TestBackend::new(100, 20);
    let mut terminal = Terminal::new(backend).unwrap();
    terminal.draw(|f| draw(f, &app)).unwrap();
    insta::assert_snapshot!(terminal.backend());
}

#[test]
fn test_snapshot_help_modal() {
    let mut app = App::with_sessions(vec![make_session(
        "abc12345-6789", "my-project",
        vec![make_msg("user", "Hello")],
    )]);
    app.toggle_help();
    let backend = TestBackend::new(100, 20);
    let mut terminal = Terminal::new(backend).unwrap();
    terminal.draw(|f| draw(f, &app)).unwrap();
    insta::assert_snapshot!(terminal.backend());
}

#[test]
fn test_snapshot_delete_confirm() {
    let mut app = App::with_sessions(vec![make_session(
        "abc12345-6789", "my-project",
        vec![make_msg("user", "Hello")],
    )]);
    app.request_delete_confirmation();
    let backend = TestBackend::new(100, 20);
    let mut terminal = Terminal::new(backend).unwrap();
    terminal.draw(|f| draw(f, &app)).unwrap();
    insta::assert_snapshot!(terminal.backend());
}
```

**Step 2: Snapshots generieren (erster Lauf schlägt fehl)**
```bash
cargo test test_snapshot_settings_modal test_snapshot_help_modal test_snapshot_delete_confirm
```
Erwartet: FAIL mit "snapshot not found"

**Step 3: Snapshots akzeptieren**
```bash
powershell.exe -Command "Set-Location 'C:\Users\g.strainovic\projects\agent-session-manager'; cargo insta review 2>&1"
```
Alle drei Snapshots mit `a` akzeptieren.

**Step 4: Tests erneut ausführen**
```bash
cargo test test_snapshot
```
Erwartet: alle grün.

**Step 5: Commit**
```bash
git add src/ui.rs src/snapshots/
git commit -m "test(ui): add insta snapshots for settings, help and delete-confirm modals"
```

---

## Task 4: Fixtures-Helper (`tests/common/mod.rs`)

**Files:**
- Create: `tests/common/mod.rs`

Shared Helper für alle Integration- und E2E-Tests.

**Step 1: Datei erstellen**

```rust
// tests/common/mod.rs
#![allow(dead_code)]

use std::path::Path;
use tempfile::TempDir;

/// Erstellt eine isolierte Testumgebung mit:
/// - CLAUDE_DATA_DIR → tmp/claude/
/// - AGENT_CONFIG_DIR → tmp/config/
/// - export_dir → tmp/exports/
pub struct TestEnv {
    pub _tmp: TempDir,     // hält TempDir am Leben
    pub claude_dir: std::path::PathBuf,
    pub config_dir: std::path::PathBuf,
    pub export_dir: std::path::PathBuf,
}

impl TestEnv {
    pub fn new() -> Self {
        let tmp = TempDir::new().expect("TempDir");
        let claude_dir = tmp.path().join("claude");
        let config_dir = tmp.path().join("config");
        let export_dir = tmp.path().join("exports");
        std::fs::create_dir_all(&claude_dir).unwrap();
        std::fs::create_dir_all(&config_dir).unwrap();
        std::fs::create_dir_all(&export_dir).unwrap();
        Self { _tmp: tmp, claude_dir, config_dir, export_dir }
    }

    /// Aktiviert Env-Vars für die aktuelle Session
    pub fn activate(&self) {
        std::env::set_var("CLAUDE_DATA_DIR", &self.claude_dir);
        std::env::set_var("AGENT_CONFIG_DIR", &self.config_dir);
    }

    /// Räumt Env-Vars auf
    pub fn deactivate() {
        std::env::remove_var("CLAUDE_DATA_DIR");
        std::env::remove_var("AGENT_CONFIG_DIR");
    }
}

/// Erzeugt eine JSONL-Session-Datei in der Testumgebung.
/// Pfad: <claude_dir>/projects/<project_slug>/sessions/<session_id>.jsonl
pub fn create_fixture_session(
    claude_dir: &Path,
    project_slug: &str,
    session_id: &str,
    messages: &[(&str, &str)],  // (role, content)
) {
    let sessions_dir = claude_dir
        .join("projects")
        .join(project_slug)
        .join("sessions");
    std::fs::create_dir_all(&sessions_dir).unwrap();

    let mut lines = Vec::new();
    for (i, (role, content)) in messages.iter().enumerate() {
        let type_ = if *role == "user" { "user" } else { "assistant" };
        let content_json = if *role == "assistant" {
            format!(r#"[{{"type":"text","text":"{}"}}]"#, content.replace('"', "\\\""))
        } else {
            format!("\"{}\"", content.replace('"', "\\\""))
        };
        lines.push(format!(
            r#"{{"type":"{}","message":{{"role":"{}","content":{}}},"uuid":"test-uuid-{:03}"}}"#,
            type_, role, content_json, i
        ));
    }

    let path = sessions_dir.join(format!("{}.jsonl", session_id));
    std::fs::write(path, lines.join("\n")).unwrap();
}
```

**Step 2: Kompilieren prüfen**
```bash
cargo test --test integration 2>&1 | head -5
```
Erwartet: "error: no test file" (Datei fehlt noch) oder Kompilierfehler → nur Kompilierfehler beheben.

**Step 3: Commit**
```bash
git add tests/common/mod.rs
git commit -m "test: add shared fixture helpers for integration and e2e tests"
```

---

## Task 5: Layer 2 — Integration Tests (`tests/integration.rs`)

**Files:**
- Create: `tests/integration.rs`

> **Wichtig:** Rust Integration-Tests für Binaries können keine `pub`-Funktionen aus `main.rs` aufrufen. Wir testen über `App`-Methoden + `commands`-Modul direkt.
> Da `agent-session-manager` nur ein `[[bin]]` target hat, müssen wir die Module via `path`-Imports nutzen. Dafür wird temporär ein `[lib]` target benötigt (nächster Task).

**Hinweis:** Task 5 hängt von Task 6 ab — erst Task 6 ausführen, dann zurückkommen.

---

## Task 6: `src/lib.rs` für Integration-Test-Zugriff

**Files:**
- Create: `src/lib.rs`
- Modify: `Cargo.toml`

Damit `tests/integration.rs` auf `App`, `SessionStore`, `AppConfig`, `commands` zugreifen kann.

**Step 1: `src/lib.rs` erstellen**

```rust
// src/lib.rs
pub mod app;
pub mod commands;
pub mod config;
pub mod models;
pub mod store;
pub mod ui;
```

**Step 2: `Cargo.toml` erweitern**

Nach `[[bin]]`:
```toml
[lib]
name = "agent_session_manager"
path = "src/lib.rs"
```

**Step 3: Kompilierung prüfen**
```bash
cargo build
```
Erwartet: Kein Fehler. (Falls `mod`-Konflikte in `main.rs`: `main.rs` nutzt weiterhin eigene `mod`-Deklarationen, die `lib.rs` ist unabhängig.)

Falls Konflikte: `main.rs` bleibt wie es ist, `lib.rs` re-exportiert nur.

**Step 4: Alle Tests noch grün**
```bash
cargo test
```

**Step 5: Commit**
```bash
git add src/lib.rs Cargo.toml
git commit -m "feat: add lib target for integration test access"
```

---

## Task 7: Layer 2 — Integration Tests ausimplementieren

**Files:**
- Create: `tests/integration.rs`

**Step 1: Datei erstellen**

```rust
// tests/integration.rs
mod common;

use agent_session_manager::app::App;
use agent_session_manager::commands;
use agent_session_manager::config::AppConfig;
use agent_session_manager::store::SessionStore;
use common::{create_fixture_session, TestEnv};

/// Hilfsfunktion: Lädt Sessions aus der TestEnv
fn load_sessions(env: &TestEnv) -> Vec<agent_session_manager::models::Session> {
    env.activate();
    let store = SessionStore::new();
    let sessions = store.load_sessions().unwrap_or_default();
    sessions
}

// ─── READ ────────────────────────────────────────────────────────────────────

#[test]
fn test_read_sessions_from_fixture_dir() {
    let env = TestEnv::new();
    create_fixture_session(
        &env.claude_dir, "-test-project",
        "session-uuid-001",
        &[("user", "Hello"), ("assistant", "Hi!")],
    );
    let sessions = load_sessions(&env);
    TestEnv::deactivate();

    assert_eq!(sessions.len(), 1);
    assert_eq!(sessions[0].messages.len(), 2);
    assert!(sessions[0].project_name.contains("test-project"));
}

#[test]
fn test_search_filters_sessions() {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-alpha-project", "uuid-001",
        &[("user", "rust programming")]);
    create_fixture_session(&env.claude_dir, "-beta-project", "uuid-002",
        &[("user", "python scripting")]);
    let sessions = load_sessions(&env);
    TestEnv::deactivate();

    let mut app = App::new(sessions, vec![]);
    app.search_query = "rust".to_string();
    let filtered = app.filtered_sessions();
    assert_eq!(filtered.len(), 1);
    assert!(filtered[0].project_name.contains("alpha"));
}

// ─── UPDATE (Settings) ───────────────────────────────────────────────────────

#[test]
fn test_settings_save_persists_to_config_file() {
    let env = TestEnv::new();
    env.activate();

    let mut app = App::new(vec![], vec![]);
    app.open_settings();
    app.settings_input = env.export_dir.to_string_lossy().to_string();
    app.save_settings();

    TestEnv::deactivate();

    let config_file = env.config_dir.join("config.json");
    assert!(config_file.exists(), "config.json muss erstellt werden");
    let loaded = AppConfig::load();
    // Da Env-Var entfernt wurde, laden wir manuell
    let content = std::fs::read_to_string(&config_file).unwrap();
    let cfg: AppConfig = serde_json::from_str(&content).unwrap();
    assert_eq!(cfg.export_path, env.export_dir.to_string_lossy());
}

#[test]
fn test_settings_cancel_does_not_save() {
    let env = TestEnv::new();
    env.activate();

    let mut app = App::new(vec![], vec![]);
    app.config.export_path = "~/original-path".to_string();
    app.open_settings();
    app.settings_input = "~/changed-path".to_string();
    app.cancel_settings();

    TestEnv::deactivate();

    assert_eq!(app.config.export_path, "~/original-path");
    assert!(!env.config_dir.join("config.json").exists());
}

// ─── EXPORT (Create File) ────────────────────────────────────────────────────

#[test]
fn test_export_creates_file_in_configured_path() {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-my-project", "session-export-001",
        &[("user", "Export this"), ("assistant", "Done!")]);
    let sessions = load_sessions(&env);
    TestEnv::deactivate();

    let session = &sessions[0];
    let result = commands::export_session(session, &env.export_dir);
    assert!(result.is_ok(), "Export fehlgeschlagen: {:?}", result);

    let files: Vec<_> = env.export_dir.read_dir().unwrap()
        .filter_map(|e| e.ok())
        .collect();
    assert_eq!(files.len(), 1, "Genau eine Datei muss exportiert werden");
    let content = std::fs::read_to_string(files[0].path()).unwrap();
    assert!(content.contains("Export this"));
    assert!(content.contains("Done!"));
}

#[test]
fn test_export_uses_config_export_path() {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-project-x", "uuid-exp",
        &[("user", "test message")]);
    let sessions = load_sessions(&env);
    env.activate();

    let mut app = App::new(sessions.clone(), vec![]);
    // Export-Pfad via Settings setzen
    app.open_settings();
    app.settings_input = env.export_dir.to_string_lossy().to_string();
    app.save_settings();

    let export_path = app.config.resolved_export_path();
    let result = commands::export_session(&sessions[0], &export_path);
    TestEnv::deactivate();

    assert!(result.is_ok());
    assert!(env.export_dir.read_dir().unwrap().count() > 0);
}

// ─── DELETE / TRASH ──────────────────────────────────────────────────────────

#[test]
fn test_delete_moves_session_to_trash() {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-del-project", "uuid-del",
        &[("user", "delete me")]);
    let sessions = load_sessions(&env);
    TestEnv::deactivate();

    let mut app = App::new(sessions, vec![]);
    assert_eq!(app.sessions.len(), 1);
    app.move_selected_to_trash();
    assert_eq!(app.sessions.len(), 0);
    assert_eq!(app.trash.len(), 1);
}

#[test]
fn test_restore_session_from_trash() {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-restore-project", "uuid-restore",
        &[("user", "restore me")]);
    let sessions = load_sessions(&env);
    TestEnv::deactivate();

    let mut app = App::new(sessions, vec![]);
    app.move_selected_to_trash();
    app.switch_tab();
    app.restore_selected_from_trash();
    assert_eq!(app.sessions.len(), 1);
    assert_eq!(app.trash.len(), 0);
}

#[test]
fn test_empty_trash() {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-p1", "uuid-t1", &[("user", "msg1")]);
    create_fixture_session(&env.claude_dir, "-p2", "uuid-t2", &[("user", "msg2")]);
    let sessions = load_sessions(&env);
    TestEnv::deactivate();

    let mut app = App::new(sessions, vec![]);
    app.move_selected_to_trash();
    app.select_next();
    app.move_selected_to_trash();
    assert_eq!(app.trash.len(), 2);

    app.switch_tab();
    app.request_empty_trash();
    app.confirm_and_execute();
    assert_eq!(app.trash.len(), 0);
}
```

**Step 2: Tests ausführen**
```bash
cargo test --test integration
```
Erwartet: Alle grün. Falls Compile-Fehler → fixe Pfade/Typen.

**Step 3: Commit**
```bash
git add tests/integration.rs
git commit -m "test(integration): add isolated CRUD integration tests for all layers"
```

---

## Task 8: `ratatui-testlib` Dependency hinzufügen

**Files:**
- Modify: `Cargo.toml`

**Step 1: Dependency hinzufügen**

In `[dev-dependencies]`:
```toml
ratatui-testlib = { version = "0.1.0", features = [] }
portable-pty = "0.8"
```

**Step 2: Kompilierung prüfen**
```bash
cargo build --tests
```

**Step 3: Commit**
```bash
git add Cargo.toml Cargo.lock
git commit -m "deps: add ratatui-testlib for PTY-based E2E tests"
```

---

## Task 9: Layer 3 — E2E PTY Tests (`tests/e2e.rs`)

**Files:**
- Create: `tests/e2e.rs`

> **Voraussetzung:** Die Binary muss gebaut sein: `cargo build`

**Step 1: Test-Datei erstellen**

```rust
// tests/e2e.rs
mod common;

use common::{create_fixture_session, TestEnv};
use portable_pty::CommandBuilder;
use ratatui_testlib::TuiTestHarness;
use std::time::Duration;

fn binary_path() -> String {
    let mut path = std::env::current_dir().expect("cwd");
    path.push("target");
    path.push("debug");
    path.push("agent-session-manager");
    #[cfg(target_os = "windows")]
    path.set_extension("exe");
    path.to_string_lossy().to_string()
}

fn launch(env: &TestEnv) -> ratatui_testlib::Result<TuiTestHarness> {
    let mut cmd = CommandBuilder::new(binary_path());
    cmd.env("CLAUDE_DATA_DIR", env.claude_dir.to_str().unwrap());
    cmd.env("AGENT_CONFIG_DIR", env.config_dir.to_str().unwrap());
    let mut harness = TuiTestHarness::new(120, 40)?;
    harness.spawn(cmd)?;
    Ok(harness)
}

// ─── READ ────────────────────────────────────────────────────────────────────

#[test]
fn e2e_shows_sessions_on_start() -> ratatui_testlib::Result<()> {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-my-project", "uuid-001",
        &[("user", "Hello World")]);

    let mut h = launch(&env)?;
    h.wait_for_text("Sessions (1)")?;
    h.wait_for_text("my-project")?;
    Ok(())
}

#[test]
fn e2e_search_filters_list() -> ratatui_testlib::Result<()> {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-alpha-project", "uuid-a",
        &[("user", "rust code")]);
    create_fixture_session(&env.claude_dir, "-beta-project", "uuid-b",
        &[("user", "python code")]);

    let mut h = launch(&env)?;
    h.wait_for_text("Sessions (2)")?;

    // Ctrl+F öffnet Suche
    h.send_text("\x06")?;  // Ctrl+F = 0x06
    h.wait_for_text("Search")?;
    h.type_text("alpha")?;
    h.wait_for_text("alpha-project")?;

    let screen = h.screen_contents();
    assert!(!screen.contains("beta-project"), "beta sollte herausgefiltert sein");
    Ok(())
}

// ─── UPDATE (Settings) ───────────────────────────────────────────────────────

#[test]
fn e2e_settings_change_and_persist() -> ratatui_testlib::Result<()> {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-proj", "uuid-s",
        &[("user", "test")]);

    let mut h = launch(&env)?;
    h.wait_for_text("Sessions")?;

    // Settings öffnen
    h.type_text("g")?;
    h.wait_for_text("Export Path")?;

    // Feld leeren (Default: ~/claude-exports = 16 Zeichen)
    for _ in 0..20 {
        h.send_key(ratatui_testlib::KeyCode::Backspace)?;
    }

    // Neuen Pfad eingeben
    let new_path = env.export_dir.to_str().unwrap();
    h.type_text(new_path)?;
    h.send_key(ratatui_testlib::KeyCode::Enter)?;
    h.wait_for_text("Settings saved")?;

    // Config-Datei prüfen
    let cfg_path = env.config_dir.join("config.json");
    assert!(cfg_path.exists());
    let content = std::fs::read_to_string(&cfg_path).unwrap();
    assert!(content.contains(new_path.replace('\\', "\\\\").as_str()));
    Ok(())
}

// ─── EXPORT ──────────────────────────────────────────────────────────────────

#[test]
fn e2e_export_creates_file_in_configured_dir() -> ratatui_testlib::Result<()> {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-export-project", "uuid-e",
        &[("user", "export this message")]);

    // Settings zuerst mit export_dir konfigurieren
    let cfg = agent_session_manager::config::AppConfig {
        export_path: env.export_dir.to_string_lossy().to_string(),
    };
    std::env::set_var("AGENT_CONFIG_DIR", &env.config_dir);
    cfg.save().unwrap();
    std::env::remove_var("AGENT_CONFIG_DIR");

    let mut h = launch(&env)?;
    h.wait_for_text("Sessions (1)")?;

    // Export mit 'e'
    h.type_text("e")?;
    h.wait_for_text("Exported to")?;

    let files: Vec<_> = env.export_dir.read_dir().unwrap()
        .filter_map(|e| e.ok()).collect();
    assert_eq!(files.len(), 1, "Genau eine Datei muss exportiert werden");
    Ok(())
}

// ─── DELETE / TRASH ──────────────────────────────────────────────────────────

#[test]
fn e2e_delete_moves_to_trash_tab() -> ratatui_testlib::Result<()> {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-delete-me", "uuid-d",
        &[("user", "to be deleted")]);

    let mut h = launch(&env)?;
    h.wait_for_text("Sessions (1)")?;

    // Delete mit 'd', dann bestätigen
    h.type_text("d")?;
    h.wait_for_text("trash")?;
    h.type_text("y")?;
    h.wait_for_text("Sessions (0)")?;

    // Trash-Tab prüfen
    h.send_key(ratatui_testlib::KeyCode::Tab)?;
    h.wait_for_text("Trash (1)")?;
    Ok(())
}

#[test]
fn e2e_restore_from_trash() -> ratatui_testlib::Result<()> {
    let env = TestEnv::new();
    create_fixture_session(&env.claude_dir, "-restore-me", "uuid-r",
        &[("user", "restore me")]);

    let mut h = launch(&env)?;
    h.wait_for_text("Sessions (1)")?;
    h.type_text("d")?;
    h.wait_for_text("trash")?;
    h.type_text("y")?;
    h.wait_for_text("Sessions (0)")?;

    // Trash-Tab → restore mit 'r'
    h.send_key(ratatui_testlib::KeyCode::Tab)?;
    h.wait_for_text("Trash (1)")?;
    h.type_text("r")?;
    h.wait_for_text("Restored")?;

    // Zurück zu Sessions
    h.send_key(ratatui_testlib::KeyCode::Tab)?;
    h.wait_for_text("Sessions (1)")?;
    Ok(())
}
```

**Step 2: Binary bauen**
```bash
cargo build
```

**Step 3: E2E Tests ausführen**
```bash
cargo test --test e2e
```

Falls `ratatui-testlib` API-Abweichungen hat (Crate v0.1.0 ist jung): Fehlermeldungen lesen und API anpassen. Die Grundstruktur bleibt gleich.

**Step 4: Commit**
```bash
git add tests/e2e.rs
git commit -m "test(e2e): add PTY-based E2E tests for full CRUD flows"
```

---

## Task 10: CI-Check & Dokumentation

**Step 1: Alle Tests komplett grün**
```bash
cargo test
```

**Step 2: CLAUDE.md aktualisieren** — Test-Abschnitt ergänzen:
- Layer 1/2/3 Struktur dokumentieren
- Env-Vars `CLAUDE_DATA_DIR`, `AGENT_CONFIG_DIR` erklären
- E2E-Tests erfordern `cargo build` zuerst

**Step 3: Final Commit**
```bash
git add CLAUDE.md
git commit -m "docs: document test layers and isolation env vars"
git push
```

---

## Reihenfolge

```
Task 1 → Task 2 → Task 3 → Task 6 → Task 4 → Task 5 → Task 7 → Task 8 → Task 9 → Task 10
```

Task 4 (Fixtures) und Task 6 (lib.rs) müssen vor Task 5 und Task 7 fertig sein.
